{"version":3,"sources":["../../src/modules/parser.js"],"names":["getQueryVars","variables","queryVars","varName","type","slice","getFields","fieldList","fieldStr","field","Object","keys","fields","checkIsObject","value","checkIsVar","indexOf","getParsedVar","checkArgVar","query","operationArg","argValue","operation","args","parsedVar","Error","escape","parseOperation","name","operationArgs","argName","alias","trim","error","message","parse","queryName","module","exports"],"mappings":"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","file":"parser.js","sourcesContent":["/**\n * @typedef {object} fieldObj Field properties\n * @prop {Array<string | Object.<string, [fieldObj]>>} [fields] Nested fields\n */\n/**\n * @typedef {object} operation An operation object\n * @prop {string} name Operation name\n * @prop {Object.<string, any> | Object.<string, {value: string, escape: boolean}>} [args] Operation arguments\n * @prop {string} [alias] Operation arguments\n * @prop {Array<string | Object.<string, [fieldObj]>>} fields Field list\n */\n/**\n * @typedef {object} queryType An getQL JSON query type\n * @prop {string} [name] Query name (it is needed when there are multiple queries)\n * @prop {operation} operation Operation object\n * @prop {Object.<string, { type: string, value: string }>} [variables] Query variables\n */\n\n/**\n * Parses query variables into strings\n * @param {Object.<string, { type: string, value: string }>} variables Variable object\n * @return {string} Parsed variables\n */\nfunction getQueryVars (variables) {\n  if (!variables) return ''\n\n  let queryVars = '('\n  for (let varName in variables) {\n    queryVars += `$${varName}: ${variables[varName].type}, `\n  }\n  return queryVars.slice(0, -2) + ') ' // Split last comma\n}\n\n/**\n * Parses fields recursively into strings\n * @param {Array<string | Object.<string, [fieldObj]>>} fieldList List of fields\n * @return {string} Parsed fields\n */\nfunction getFields (fieldList) {\n  if (!fieldList) return '' // Return condition, reached bottom of tree\n  let fieldStr = ''\n  for (let field of fieldList) {\n    if (typeof field === 'string') fieldStr += `${field} ` // Return plain string field\n    /* istanbul ignore next */\n    else if (typeof field === 'object') {\n      fieldStr += `${Object.keys(field)[0]} { ${getFields(field[Object.keys(field)[0]].fields)}} ` // Get fields recursively if nested\n    }\n  }\n  return fieldStr\n}\n\n/**\n * Checks if the value is an object\n * @param {any} varName Object to be checked\n * @return {boolean} True if is object\n */\nfunction checkIsObject (varName) {\n  return (typeof varName === 'object' && varName.value)\n}\n\n/**\n * Outputs true if the argument is a variable\n * @param {string|object} varName Variable value or object\n * @return {boolean} True if it is a variable\n */\nfunction checkIsVar (varName) {\n  if (checkIsObject(varName)) return false\n  return varName.indexOf('$') === 0\n}\n\n/**\n * Parses the variable name into a string to be used.\n *\n * If variable is an object, then it is a query variable and must be treated differently\n * @param {string|object} varName Variable value or object\n * @return {string} Parsed variablename\n */\nfunction getParsedVar (varName) {\n  if (checkIsObject(varName)) return `\"${varName.value}\"`\n  return `\"${varName}\"`\n}\n\n/**\n * Checks if the operation argument is a variable or not\n *\n * Also checks if the variables are indeed set in the query before using it in the operation\n * @param {queryType} query The JSON-like query\n * @param {string} operationArg Argument name\n * @returns {string} Parsed operation argument\n */\nfunction checkArgVar (query, operationArg) {\n  const argValue = query.operation.args[operationArg]\n  let parsedVar = getParsedVar(argValue)\n\n  if (checkIsVar(argValue)) { // Check if is query var, must contain \"$\" and not be an object\n    parsedVar = argValue\n    const varName = parsedVar.slice(1) // Removes \"$\" to check for name\n\n    if (!query.variables || !query.variables[varName] || !query.variables[varName].type || !query.variables[varName].value) {\n      throw new Error(`Variable \"${varName}\" is defined on operation but it has neither a type or a value`)\n    }\n  } else if (checkIsObject(argValue)) { // Check if arg is object (i.e enum)\n    if (!argValue.escape) {\n      parsedVar = argValue.value\n    }\n  }\n\n  return parsedVar\n}\n\n/**\n * Parses the operation bit of the query\n * @param {queryType} query The JSON-Like query to be parsed\n * @return {string} Parsed operation query\n */\nfunction parseOperation (query) {\n  let operation = query.operation\n  if (!operation.name) throw new Error(`name is required for graphQL operation`)\n  if (!operation.fields) throw new Error(`field list is required for operation \"${operation.name}\"`)\n\n  try {\n    let operationArgs = ''\n    if (operation.args) {\n      for (let argName in operation.args) {\n        operationArgs += `${argName}: ${checkArgVar(query, argName)}, ` // There'll be a last comma we'll strip later\n      }\n      operationArgs = `(${operationArgs.slice(0, -2)})`\n    }\n\n    let alias = operation.alias ? `${operation.alias}:` : ''\n    return `${alias} ${operation.name}${operationArgs} { ${getFields(operation.fields).trim()} }`.trim()\n  } catch (error) {\n    throw new Error(`Failed to parse operation \"${query.operation.name}\" => ${error.message}`)\n  }\n}\n\n/**\n * Parses a JSON-like query into a string\n * @param {queryType} query The JSON-like query to be parsed\n * @param {string} type Can be 'query' or 'mutation'\n * @return {string} Parsed query\n */\nfunction parse (query, type) {\n  try {\n    if (!query.operation) throw new Error('a query must have at least one operation')\n    if (!type) throw new Error('type must be either \"query\" or \"mutation\"')\n\n    let queryName = (query.name) ? `${query.name} ` : ''\n    return `${type.trim()} ${queryName}${getQueryVars(query.variables)}{ ${parseOperation(query)} }`.trim()\n  } catch (error) {\n    throw new Error(`Parse error: ${error.message}`)\n  }\n}\n\nmodule.exports = parse\n"]}